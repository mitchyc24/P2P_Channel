<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Channel</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- FontAwesome for Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Google Fonts (JetBrains Mono for that hacker feel) -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- PeerJS for WebRTC -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        :root {
            --bg-dark: #0f111a;
            --bg-panel: #1a1d2d;
            --accent: #00ff9d;
            --accent-dim: rgba(0, 255, 157, 0.1);
            --text-main: #e0e6ed;
            --text-muted: #8b949e;
            --danger: #ff4b4b;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Login Overlay --- */
        #login-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-dark);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        .login-card {
            background: var(--bg-panel);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 2rem;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .role-selector .btn-check:checked + .btn-outline-success {
            background-color: var(--accent);
            color: #000;
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-dim);
        }

        .btn-connect {
            background: var(--accent);
            color: #000;
            font-weight: 700;
            border: none;
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            transition: all 0.3s;
        }
        .btn-connect:hover {
            background: #00cc7d;
            box-shadow: 0 0 20px var(--accent-dim);
        }
        .btn-connect:disabled {
            background: #333;
            color: #666;
        }

        /* --- Main Interface --- */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .app-container.active {
            opacity: 1;
            pointer-events: all;
        }

        .status-bar {
            height: 60px;
            background: var(--bg-panel);
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
        }

        .connection-status {
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: #666;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: background 0.3s;
        }
        .status-dot.connected { background: var(--accent); box-shadow: 0 0 10px var(--accent); }
        .status-dot.error { background: var(--danger); }
        .status-dot.waiting { background: #ffcc00; animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .workspace {
            flex: 1;
            display: flex;
            padding: 1rem;
            gap: 1rem;
        }

        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            border-radius: 8px;
            border: 1px solid #30363d;
            overflow: hidden;
            position: relative;
        }

        .panel-header {
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid #30363d;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-main);
            padding: 15px;
            resize: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            line-height: 1.5;
            outline: none;
        }
        
        textarea::placeholder { color: #444; }

        /* Remote view shouldn't be editable by user technically, but we use textarea for ease of scrolling */
        #remote-text {
            background: rgba(0, 0, 0, 0.2);
        }

        .encryption-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(0, 255, 157, 0.1);
            color: var(--accent);
            border: 1px solid rgba(0, 255, 157, 0.2);
        }
    </style>
</head>
<body>

    <!-- LOGIN / SETUP SCREEN -->
    <div id="login-overlay">
        <div class="login-card">
            <h3 class="text-center mb-4"><i class="fas fa-shield-alt text-success"></i> Peer-2-Peer</h3>
            <p class="text-muted text-center small mb-4">Secure, Serverless, Real-Time Key Exchange</p>
            
            <div class="mb-4">
                <label class="form-label small text-uppercase text-muted">1. Choose Role</label>
                <div class="btn-group w-100 role-selector" role="group">
                    <input type="radio" class="btn-check" name="role" id="roleHost" value="host" checked>
                    <label class="btn btn-outline-success" for="roleHost"><i class="fas fa-server"></i> Host</label>
                    
                    <input type="radio" class="btn-check" name="role" id="roleJoin" value="join">
                    <label class="btn btn-outline-success" for="roleJoin"><i class="fas fa-satellite-dish"></i> Join</label>
                </div>
            </div>

            <div class="mb-3">
                <label class="form-label small text-uppercase text-muted">2. Shared Secret Key</label>
                <div class="input-group">
                    <span class="input-group-text bg-dark border-secondary text-light"><i class="fas fa-key"></i></span>
                    <input type="password" id="secretKey" class="form-control bg-dark border-secondary text-light" placeholder="Enter offline agreed key...">
                    <button class="btn btn-outline-secondary" type="button" id="togglePass">
                        <i class="fas fa-eye"></i>
                    </button>
                </div>
                <div class="form-text text-muted" style="font-size: 0.75rem;">
                    * This key derives the encryption & connection ID.
                </div>
            </div>

            <button id="btnConnect" class="btn-connect" onclick="initApp()">ESTABLISH LINK</button>
            <div id="login-msg" class="text-center mt-3 text-danger small"></div>
        </div>
    </div>

    <!-- MAIN APP UI -->
    <div class="app-container" id="appContainer">
        <!-- Header -->
        <div class="status-bar">
            <div class="brand fw-bold"><i class="fas fa-terminal text-success"></i> SECURE_CHANNEL</div>
            
            <div class="connection-status">
                <span id="statusText">Initializing...</span>
                <div id="statusDot" class="status-dot"></div>
                <button class="btn btn-sm btn-outline-danger ms-3" onclick="location.reload()">
                    <i class="fas fa-power-off"></i>
                </button>
            </div>
        </div>

        <!-- Work Area -->
        <div class="workspace">
            <!-- Local Input -->
            <div class="editor-panel">
                <div class="panel-header">
                    <span><i class="fas fa-keyboard me-2"></i> Local Buffer</span>
                    <span class="encryption-badge"><i class="fas fa-lock"></i> AES-GCM-256</span>
                </div>
                <textarea id="local-text" placeholder="Type here to transmit secure data..." spellcheck="false"></textarea>
            </div>

            <!-- Remote Output -->
            <div class="editor-panel">
                <div class="panel-header">
                    <span><i class="fas fa-satellite me-2"></i> Remote Stream</span>
                    <span class="encryption-badge" id="remote-status"><i class="fas fa-wifi"></i> Waiting</span>
                </div>
                <textarea id="remote-text" readonly placeholder="Incoming transmission..." spellcheck="false"></textarea>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let peer = null;
        let conn = null;
        let encryptionKey = null; // CryptoKey object
        const APP_PREFIX = "secure_channel_v1_"; // To separate this app from others on PeerJS server

        // --- UI HANDLERS ---
        document.getElementById('togglePass').addEventListener('click', () => {
            const input = document.getElementById('secretKey');
            input.type = input.type === 'password' ? 'text' : 'password';
        });

        // --- CRYPTO FUNCTIONS (Web Crypto API) ---

        // 1. Derive a 256-bit AES-GCM key from the user's password using PBKDF2
        async function deriveKey(password) {
            const enc = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw", 
                enc.encode(password), 
                { name: "PBKDF2" }, 
                false, 
                ["deriveKey"]
            );

            // Using a hardcoded salt ensures both peers derive the exact same key from the same password.
            // In a more complex app, you might exchange a random salt during handshake, 
            // but for a simple "shared secret" offline model, a static salt is acceptable/necessary.
            const salt = enc.encode("SECURE_CHANNEL_STATIC_SALT_V1"); 

            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        // 2. Encrypt Data
        async function encryptData(text) {
            if (!encryptionKey) return null;
            const enc = new TextEncoder();
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); // Random IV every time
            const encodedText = enc.encode(text);

            const encryptedBuffer = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                encryptionKey,
                encodedText
            );

            // We need to send both the IV and the Encrypted Data
            // Format: JSON string { iv: [array], data: [array] }
            return JSON.stringify({
                iv: Array.from(iv),
                data: Array.from(new Uint8Array(encryptedBuffer))
            });
        }

        // 3. Decrypt Data
        async function decryptData(jsonString) {
            if (!encryptionKey) return "";
            try {
                const payload = JSON.parse(jsonString);
                const iv = new Uint8Array(payload.iv);
                const data = new Uint8Array(payload.data);

                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    encryptionKey,
                    data
                );

                const dec = new TextDecoder();
                return dec.decode(decryptedBuffer);
            } catch (e) {
                console.error("Decryption failed:", e);
                return "[DECRYPTION ERROR - KEY MISMATCH?]";
            }
        }

        // 4. Generate a deterministic ID based on the password (SHA-256)
        // This allows the "Host" to always grab the same ID so the "Joiner" knows where to look.
        async function generateRoomId(password) {
            const enc = new TextEncoder();
            const data = enc.encode(password + "ROOM_ID_SALT"); // Different salt than encryption
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex.substring(0, 16); // Use first 16 chars as ID
        }


        // --- MAIN APP LOGIC ---

        async function initApp() {
            const secret = document.getElementById('secretKey').value;
            const role = document.querySelector('input[name="role"]:checked').value;
            const btn = document.getElementById('btnConnect');
            const msg = document.getElementById('login-msg');

            if (secret.length < 4) {
                msg.innerText = "Secret key is too short.";
                return;
            }

            // Disable UI
            btn.disabled = true;
            btn.innerText = "GENERATING KEYS...";

            try {
                // 1. Generate Crypto Key
                encryptionKey = await deriveKey(secret);
                
                // 2. Generate Room Hash
                const roomId = await generateRoomId(secret);
                const hostId = `${APP_PREFIX}${roomId}_HOST`;

                // 3. Initialize PeerJS
                btn.innerText = "CONTACTING SIGNALING SERVER...";
                
                if (role === 'host') {
                    setupHost(hostId);
                } else {
                    setupJoiner(hostId);
                }

            } catch (err) {
                console.error(err);
                msg.innerText = "Error initializing crypto engine.";
                btn.disabled = false;
            }
        }

        function setupHost(myId) {
            // Initialize Peer with specific ID
            peer = new Peer(myId, {
                debug: 2
            });

            peer.on('open', (id) => {
                transitionToApp("Waiting for Peer...", "waiting");
                
                // Listen for connections
                peer.on('connection', (c) => {
                    handleConnection(c);
                });
            });

            peer.on('error', (err) => {
                if(err.type === 'unavailable-id') {
                    alert("ID taken. Someone is already Hosting with this key. Try Joining instead.");
                    location.reload();
                } else {
                    handleError(err);
                }
            });
        }

        function setupJoiner(targetId) {
            // Joiner gets a random ID
            peer = new Peer(null, {
                debug: 2
            });

            peer.on('open', (id) => {
                transitionToApp("Connecting to Host...", "waiting");
                // Connect to the Host
                const c = peer.connect(targetId);
                handleConnection(c);
            });

            peer.on('error', (err) => {
                handleError(err);
            });
        }

        function handleConnection(connection) {
            conn = connection;

            conn.on('open', () => {
                updateStatus("SECURE CHANNEL ESTABLISHED", "connected");
                document.getElementById('remote-status').innerHTML = '<i class="fas fa-link"></i> Live';
                document.getElementById('remote-status').classList.replace('text-muted', 'text-success');
            });

            conn.on('data', async (data) => {
                // Decrypt incoming data
                const text = await decryptData(data);
                document.getElementById('remote-text').value = text;
            });

            conn.on('close', () => {
                updateStatus("Peer Disconnected", "error");
                conn = null;
            });
        }

        function handleError(err) {
            console.error(err);
            const msg = document.getElementById('login-msg');
            msg.innerText = "Connection Error: " + err.type;
            document.getElementById('btnConnect').disabled = false;
            document.getElementById('btnConnect').innerText = "TRY AGAIN";
        }

        // --- TRANSITIONS & UPDATES ---

        function transitionToApp(initialStatus, dotClass) {
            document.getElementById('login-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('login-overlay').style.display = 'none';
                document.getElementById('appContainer').classList.add('active');
            }, 500);
            updateStatus(initialStatus, dotClass);
        }

        function updateStatus(text, dotClass) {
            document.getElementById('statusText').innerText = text;
            const dot = document.getElementById('statusDot');
            dot.className = 'status-dot ' + dotClass;
        }

        // --- REAL-TIME TYPING LOGIC ---

        const localInput = document.getElementById('local-text');
        
        localInput.addEventListener('keyup', async () => {
            if (conn && conn.open) {
                const rawText = localInput.value;
                const encryptedPackage = await encryptData(rawText);
                conn.send(encryptedPackage);
            }
        });

    </script>
</body>
</html>