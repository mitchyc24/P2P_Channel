<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MESH | Decentralized Encrypted Chat</title>
    
    <!-- Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <style>
        /* Dark Theme (Default) */
        :root, [data-theme="dark"] {
            --bg-color: #0d1117;
            --sidebar-color: #161b22;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-color: #58a6ff;
            --msg-bg-self: #1f6feb;
            --msg-bg-peer: #21262d;
            --font-main: 'JetBrains Mono', monospace;
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-color: #ffffff;
            --sidebar-color: #f6f8fa;
            --border-color: #d0d7de;
            --text-primary: #1f2328;
            --text-secondary: #656d76;
            --accent-color: #0969da;
            --msg-bg-self: #0969da;
            --msg-bg-peer: #f6f8fa;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-main);
            height: 100vh;
            overflow: hidden;
        }

        /* Login Screen */
        #login-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .login-card {
            background-color: var(--sidebar-color);
            border: 1px solid var(--border-color);
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        .form-control, .form-control:focus {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-family: var(--font-main);
            padding: 0.75rem;
            font-size: 1rem;
        }

        .form-control::placeholder {
            color: var(--text-secondary);
        }

        .btn-primary {
            background-color: var(--accent-color);
            border: none;
            color: #fff;
            font-weight: 700;
            padding: 0.75rem;
        }

        [data-theme="dark"] .btn-primary {
            color: #000;
        }

        .btn-primary:hover {
            background-color: var(--accent-color);
            opacity: 0.9;
        }

        /* Icon Buttons */
        .btn-icon {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .btn-icon:hover {
            background-color: var(--border-color);
        }
        
        /* App Layout */
        #app-container {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            display: flex;
            position: relative;
        }

        /* Sidebar */
        #sidebar {
            width: 280px;
            background-color: var(--sidebar-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
        }

        .channel-info {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .peer-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .peer-item {
            padding: 8px 0;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .peer-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background-color: #2ea043; }
        
        /* Theme Toggle Button */
        .btn-theme {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .btn-theme:hover {
            background-color: var(--border-color);
        }

        /* Mobile Toggle Button */
        #mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.4rem;
            padding: 0.5rem;
            min-width: 44px;
            min-height: 44px;
        }

        /* Chat Area */
        #chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            min-width: 0;
            height: 100%;
            height: 100dvh;
        }

        #chat-header {
            display: none;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--sidebar-color);
            align-items: center;
            gap: 0.5rem;
        }

        #messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-height: 0; /* Important for flex shrinking */
        }

        .message {
            max-width: 85%;
            padding: 0.6rem 1rem;
            border-radius: 12px;
            font-size: 0.95rem;
            word-wrap: break-word;
        }

        .message-self {
            align-self: flex-end;
            background-color: var(--msg-bg-self);
            color: #fff;
            border-bottom-right-radius: 4px;
        }

        .message-peer {
            align-self: flex-start;
            background-color: var(--msg-bg-peer);
            border: 1px solid var(--border-color);
            border-bottom-left-radius: 4px;
        }

        .message-system {
            align-self: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            padding: 0.25rem 0.75rem;
        }

        .message-meta {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-bottom: 2px;
            font-weight: 700;
        }

        #input-area {
            padding: 1rem;
            background-color: var(--sidebar-color);
            border-top: 1px solid var(--border-color);
            padding-bottom: calc(1rem + env(safe-area-inset-bottom, 0px)); /* iOS safe area */
        }

        #input-area .form-control {
            border-radius: 20px 0 0 20px;
        }

        #input-area .btn-primary {
            border-radius: 0 20px 20px 0;
            min-width: 50px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            #sidebar {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                width: 85%;
                max-width: 320px;
                z-index: 100;
                transform: translateX(-100%);
                box-shadow: 2px 0 15px rgba(0,0,0,0.3);
            }

            #sidebar.active {
                transform: translateX(0);
            }

            #chat-header {
                display: flex;
                justify-content: space-between;
            }

            #mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            #sidebar-overlay {
                display: none;
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 90;
            }
            
            #sidebar-overlay.active {
                display: block;
            }

            .message {
                max-width: 90%;
            }

            #input-area {
                flex-shrink: 0; /* Prevent input from shrinking */
                padding: 0.75rem;
                padding-bottom: calc(0.75rem + env(safe-area-inset-bottom, 0px));
            }

            .login-card {
                padding: 1.5rem;
            }
        }

        /* Desktop: hide overlay always */
        @media (min-width: 769px) {
            #sidebar-overlay {
                display: none !important;
            }
        }

        /* About Modal Styles */
        .modal-content {
            background-color: var(--sidebar-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .modal-header {
            border-bottom: 1px solid var(--border-color);
        }

        .modal-footer {
            border-top: 1px solid var(--border-color);
        }

        .btn-close {
            filter: var(--bs-btn-close-white-filter);
        }

        [data-theme="light"] .btn-close {
            filter: none;
        }

        .about-section {
            margin-bottom: 1.5rem;
        }

        .about-section:last-child {
            margin-bottom: 0;
        }

        .about-section h6 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .about-section p, .about-section ul {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0;
        }

        .about-section ul {
            padding-left: 1.25rem;
        }

        .about-section li {
            margin-bottom: 0.25rem;
        }

        .about-icon {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>

    <!-- About Modal -->
    <div class="modal fade" id="aboutModal" tabindex="-1" aria-labelledby="aboutModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="aboutModalLabel"><i class="fas fa-network-wired me-2"></i>About MESH</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="text-center mb-4">
                        <div class="about-icon"><i class="fas fa-shield-halved"></i></div>
                        <p class="text-secondary">Decentralized • Encrypted • Private</p>
                    </div>

                    <div class="about-section">
                        <h6><i class="fas fa-info-circle me-2"></i>What is MESH?</h6>
                        <p>MESH is a browser-based, peer-to-peer encrypted group chat application. It enables multiple users to communicate securely in real-time without requiring a central server to store or relay messages.</p>
                    </div>

                    <div class="about-section">
                        <h6><i class="fas fa-lock me-2"></i>Security</h6>
                        <ul>
                            <li><strong>End-to-End Encryption:</strong> All messages are encrypted using AES-256-GCM before transmission</li>
                            <li><strong>Key Derivation:</strong> Encryption keys are derived from your channel key using PBKDF2 with 100,000 iterations</li>
                            <li><strong>Zero Storage:</strong> Messages are never stored on any server - they exist only in browser memory</li>
                            <li><strong>No Accounts:</strong> No registration, no tracking, no data collection</li>
                        </ul>
                    </div>

                    <div class="about-section">
                        <h6><i class="fas fa-diagram-project me-2"></i>How It Works</h6>
                        <ul>
                            <li><strong>1. Join:</strong> Enter a nickname and shared channel key</li>
                            <li><strong>2. Connect:</strong> Your browser connects directly to other peers using WebRTC</li>
                            <li><strong>3. Mesh:</strong> Each peer connects to all others, forming a resilient mesh network</li>
                            <li><strong>4. Chat:</strong> Messages are encrypted locally and broadcast to all peers</li>
                        </ul>
                    </div>

                    <div class="about-section">
                        <h6><i class="fas fa-feather me-2"></i>Simplicity</h6>
                        <ul>
                            <li>Single HTML file - no installation required</li>
                            <li>Works in any modern browser</li>
                            <li>No accounts or sign-ups</li>
                            <li>Just share the channel key with your group</li>
                        </ul>
                    </div>

                    <div class="about-section">
                        <h6><i class="fas fa-triangle-exclamation me-2"></i>Important Notes</h6>
                        <ul>
                            <li>Share your channel key securely (in person, encrypted message, etc.)</li>
                            <li>All users must enter the <em>exact same</em> channel key</li>
                            <li>Messages are only available while peers are connected</li>
                            <li>WebRTC may expose your IP address to other peers</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <small class="text-secondary me-auto">Built with WebRTC, PeerJS & Web Crypto API</small>
                    <button type="button" class="btn btn-primary btn-sm" data-bs-dismiss="modal">Got it</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Login Screen -->
    <div id="login-screen">
        <div class="login-card">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 class="m-0"><i class="fas fa-network-wired"></i> MESH</h2>
                <div class="d-flex gap-2">
                    <button class="btn-icon" id="login-about-btn" title="About MESH" data-bs-toggle="modal" data-bs-target="#aboutModal">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="btn-icon" id="login-theme-toggle" title="Toggle theme">
                        <i class="fas fa-moon"></i>
                    </button>
                </div>
            </div>
            <div class="mb-3">
                <label class="form-label text-secondary">NICKNAME</label>
                <input type="text" id="input-nickname" class="form-control" autocomplete="off" placeholder="Enter ID...">
            </div>
            <div class="mb-4">
                <label class="form-label text-secondary">CHANNEL KEY</label>
                <input type="password" id="input-key" class="form-control" placeholder="Shared Secret...">
            </div>
            <button id="btn-join" class="btn btn-primary w-100">JOIN CHANNEL</button>
            <div id="login-status" class="mt-3 text-center text-danger small"></div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="d-none">
        
        <!-- Mobile Overlay -->
        <div id="sidebar-overlay"></div>

        <!-- Sidebar -->
        <div id="sidebar">
            <div class="channel-info">
                <div class="d-flex justify-content-between align-items-start mb-2">
                    <div>
                        <h5 class="m-0"><i class="fas fa-hashtag"></i> <span id="display-channel-id">UNKNOWN</span></h5>
                        <div class="small text-secondary mt-1" id="my-peer-id-display">Connecting...</div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn-icon" id="sidebar-about-btn" title="About MESH" data-bs-toggle="modal" data-bs-target="#aboutModal">
                            <i class="fas fa-info-circle"></i>
                        </button>
                        <button class="btn-icon" id="sidebar-theme-toggle" title="Toggle theme">
                            <i class="fas fa-moon"></i>
                        </button>
                        <button class="btn-icon d-md-none" id="btn-close-sidebar">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="small text-secondary px-3 pt-3">CONNECTED PEERS</div>
            <div id="peer-list-container" class="peer-list">
                <!-- Peers injected here -->
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-area">
            <!-- Mobile Header -->
            <div id="chat-header">
                <button id="mobile-menu-btn"><i class="fas fa-bars"></i></button>
                <div class="fw-bold flex-grow-1 text-center">MESH CHAT</div>
                <button class="btn-icon" id="header-theme-toggle" title="Toggle theme">
                    <i class="fas fa-moon"></i>
                </button>
            </div>

            <div id="messages-container">
                <div class="message message-system">Welcome to the mesh. Messages are end-to-end encrypted.</div>
            </div>
            <div id="input-area">
                <div class="input-group">
                    <input type="text" id="message-input" class="form-control" placeholder="Broadcast message..." autocomplete="off">
                    <button class="btn btn-primary" id="btn-send"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // THEME MANAGEMENT
        // ==========================================
        function initTheme() {
            const saved = localStorage.getItem('mesh-theme');
            const theme = saved || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
            updateThemeIcons(theme);
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('mesh-theme', next);
            updateThemeIcons(next);
        }

        function updateThemeIcons(theme) {
            const icon = theme === 'dark' ? 'fa-moon' : 'fa-sun';
            document.querySelectorAll('#login-theme-toggle i, #sidebar-theme-toggle i, #header-theme-toggle i').forEach(el => {
                el.className = `fas ${icon}`;
            });
        }

        // Initialize theme on load
        initTheme();

        // Theme toggle listeners
        document.getElementById('login-theme-toggle').addEventListener('click', toggleTheme);
        document.getElementById('sidebar-theme-toggle').addEventListener('click', toggleTheme);
        document.getElementById('header-theme-toggle').addEventListener('click', toggleTheme);

        // ==========================================
        // STATE & GLOBALS
        // ==========================================
        let peer = null;
        let myNickname = '';
        let myPeerId = '';
        let channelHashShort = '';
        
        // Crypto KeyObjects
        let aesKey = null; // CryptoKey for encryption/decryption
        
        // Network State
        const connections = {}; // remotePeerId -> DataConnection
        const peersData = {};   // remotePeerId -> { nickname }
        const processedMsgIds = new Set(); // Dedup
        
        // ==========================================
        // CRYPTO UTILS
        // ==========================================
        const CRYPTO_SALT_ITERATIONS = 100000;

        async function initSecurity(password) {
            const enc = new TextEncoder();
            const passwordKey = await window.crypto.subtle.importKey(
                "raw", 
                enc.encode(password), 
                { name: "PBKDF2" }, 
                false, 
                ["deriveBits", "deriveKey"]
            );

            // 1. Generate Channel Hash (Public ID)
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', enc.encode(password));
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const fullHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            channelHashShort = fullHash.substring(0, 16);

            // 2. Derive Encryption Key (Private)
            // We use the channel hash as a deterministic salt so all peers derive same key
            const salt = enc.encode(fullHash); 

            aesKey = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: CRYPTO_SALT_ITERATIONS,
                    hash: "SHA-256"
                },
                passwordKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
            
            return channelHashShort;
        }

        async function encryptText(text) {
            const enc = new TextEncoder();
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                aesKey,
                enc.encode(text)
            );
            
            // Pack IV + Ciphertext
            return {
                iv: Array.from(iv),
                data: Array.from(new Uint8Array(ciphertext))
            };
        }

        async function decryptText(payload) {
            try {
                const iv = new Uint8Array(payload.iv);
                const data = new Uint8Array(payload.data);
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    aesKey,
                    data
                );
                return new TextDecoder().decode(decrypted);
            } catch (e) {
                console.error("Decryption failed", e);
                return null;
            }
        }

        // ==========================================
        // PEERJS NETWORK LOGIC
        // ==========================================
        
        function initializeMesh(channelId) {
            // Deterministic Beacon ID for this channel
            const beaconId = `mesh-v1-${channelId}-b0`;
            
            // Attempt to claim Beacon Slot 0
            console.log("Attempting to become beacon:", beaconId);
            const tryPeer = new Peer(beaconId, {
                debug: 1
            });

            tryPeer.on('open', (id) => {
                console.log("I am the beacon:", id);
                finalizePeerSetup(tryPeer, true);
            });

            tryPeer.on('error', (err) => {
                if (err.type === 'unavailable-id') {
                    console.log("Beacon exists. Joining as regular peer.");
                    // Beacon taken, create random peer and connect to beacon
                    const clientPeer = new Peer(null, { debug: 1 });
                    
                    clientPeer.on('open', (id) => {
                        console.log("Joined as client:", id);
                        finalizePeerSetup(clientPeer, false, beaconId);
                    });
                } else {
                    document.getElementById('login-status').innerText = "Connection Error: " + err.type;
                }
            });
        }

        function finalizePeerSetup(p, isBeacon, targetBeaconId = null) {
            peer = p;
            myPeerId = p.id;

            // UI Updates
            document.getElementById('login-screen').classList.add('d-none');
            document.getElementById('app-container').classList.remove('d-none');
            document.getElementById('display-channel-id').innerText = channelHashShort.toUpperCase();
            document.getElementById('my-peer-id-display').innerText = myNickname + (isBeacon ? " (BEACON)" : "");

            // Initial Connection
            if (targetBeaconId) {
                connectToPeer(targetBeaconId);
            }

            // Handlers
            peer.on('connection', handleConnection);
            
            peer.on('error', err => {
                console.error("Peer Error:", err);
                addSystemMessage("Network error: " + err.type);
            });
        }

        function connectToPeer(remoteId) {
            if (connections[remoteId] || remoteId === myPeerId) return;
            
            console.log("Connecting to:", remoteId);
            const conn = peer.connect(remoteId);
            handleConnection(conn);
        }

        function handleConnection(conn) {
            conn.on('open', () => {
                // Register connection
                connections[conn.peer] = conn;
                console.log("Connected to:", conn.peer);
                
                // 1. Send Handshake (Nickname)
                sendPacket(conn, 'shake', { nickname: myNickname });
                
                // 2. Gossip: Send known peers to new connection so they can mesh
                const knownPeers = Object.keys(connections).filter(id => id !== conn.peer);
                if (knownPeers.length > 0) {
                    sendPacket(conn, 'peers', { list: knownPeers });
                }
            });

            conn.on('data', async (data) => {
                await handleData(conn.peer, data);
            });

            conn.on('close', () => {
                console.log("Closed connection:", conn.peer);
                delete connections[conn.peer];
                delete peersData[conn.peer];
                updatePeerListUI();
            });
            
            conn.on('error', (err) => {
                console.error("Conn error:", err);
                // PeerJS automatically closes on fatal errors often, but we ensure cleanup
                if(connections[conn.peer]) conn.close();
            });
        }

        function sendPacket(conn, type, payload) {
            if(conn && conn.open) {
                conn.send({ type, payload });
            }
        }

        function broadcast(type, payload, excludeId = null) {
            Object.values(connections).forEach(conn => {
                if (conn.peer !== excludeId) {
                    sendPacket(conn, type, payload);
                }
            });
        }

        async function handleData(senderId, packet) {
            const { type, payload } = packet;

            if (type === 'shake') {
                peersData[senderId] = { nickname: payload.nickname };
                updatePeerListUI();
                addSystemMessage(`${payload.nickname} joined the mesh.`);
            }
            else if (type === 'peers') {
                // Connect to new peers discovered via gossip
                payload.list.forEach(peerId => {
                    if (peerId !== myPeerId && !connections[peerId]) {
                        connectToPeer(peerId);
                    }
                });
            }
            else if (type === 'chat') {
                // Deduplicate
                if (processedMsgIds.has(payload.id)) return;
                processedMsgIds.add(payload.id);

                // Decrypt
                const plainText = await decryptText(payload.content);
                if (plainText !== null) {
                    addMessageToUI(peersData[senderId]?.nickname || "Unknown", plainText, false);
                    
                    // Mesh Relay: Re-broadcast to others who might not have received it directly
                    // This ensures full coverage even if not fully meshed
                    broadcast('chat', payload, senderId); 
                }
            }
        }

        // ==========================================
        // UI FUNCTIONS
        // ==========================================
        
        // Mobile Sidebar Toggle Logic
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebar-overlay');
        
        document.getElementById('mobile-menu-btn').addEventListener('click', () => {
            sidebar.classList.add('active');
            overlay.classList.add('active');
        });

        function closeSidebar() {
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
        }

        document.getElementById('btn-close-sidebar').addEventListener('click', closeSidebar);
        overlay.addEventListener('click', closeSidebar);

        document.getElementById('btn-join').addEventListener('click', async () => {
            const nick = document.getElementById('input-nickname').value.trim();
            const key = document.getElementById('input-key').value;

            if (!nick || !key) return alert("Please enter both Nickname and Channel Key");

            myNickname = nick;
            document.getElementById('btn-join').disabled = true;
            document.getElementById('btn-join').innerText = "Generating Keys...";

            // Initialize Crypto & Network
            const cid = await initSecurity(key);
            initializeMesh(cid);
        });

        document.getElementById('btn-send').addEventListener('click', sendMessage);
        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const text = input.value.trim();
            if (!text) return;

            input.value = '';
            
            // 1. Create Message ID
            const msgId =  Math.random().toString(36).substr(2, 9);
            processedMsgIds.add(msgId);

            // 2. Encrypt
            const encryptedContent = await encryptText(text);

            // 3. Display Self
            addMessageToUI("Me", text, true);

            // 4. Broadcast
            const payload = {
                id: msgId,
                timestamp: Date.now(),
                content: encryptedContent
            };
            broadcast('chat', payload);
        }

        function addMessageToUI(sender, text, isSelf) {
            const container = document.getElementById('messages-container');
            const div = document.createElement('div');
            div.className = `message ${isSelf ? 'message-self' : 'message-peer'}`;
            
            const meta = document.createElement('div');
            meta.className = 'message-meta';
            meta.innerText = sender;
            
            const body = document.createElement('div');
            body.innerText = text; // Secure text insertion

            if (!isSelf) div.appendChild(meta);
            div.appendChild(body);
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function addSystemMessage(text) {
            const container = document.getElementById('messages-container');
            const div = document.createElement('div');
            div.className = 'message message-system';
            div.innerText = text;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function updatePeerListUI() {
            const container = document.getElementById('peer-list-container');
            container.innerHTML = '';
            
            Object.keys(connections).forEach(id => {
                const info = peersData[id];
                const div = document.createElement('div');
                div.className = 'peer-item';
                div.innerHTML = `<span class="peer-status status-online"></span> ${info ? info.nickname : id.substring(0,8) + '...'}`;
                container.appendChild(div);
            });
        }
    </script>
</body>
</html>
